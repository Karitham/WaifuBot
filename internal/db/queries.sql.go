// Code generated by sqlc. DO NOT EDIT.
// source: queries.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const addDropToken = `-- name: addDropToken :exec
UPDATE users
SET tokens = tokens + 1
WHERE user_id = $1
`

func (q *Queries) addDropToken(ctx context.Context, userID uint64) error {
	_, err := q.exec(ctx, q.addDropTokenStmt, addDropToken, userID)
	return err
}

const consumeDropTokens = `-- name: consumeDropTokens :one
UPDATE users
SET tokens = tokens - $1
WHERE user_id = $2
RETURNING id, user_id, quote, date, favorite, tokens
`

type consumeDropTokensParams struct {
	Tokens int32  `json:"tokens"`
	UserID uint64 `json:"user_id"`
}

func (q *Queries) consumeDropTokens(ctx context.Context, arg consumeDropTokensParams) (User, error) {
	row := q.queryRow(ctx, q.consumeDropTokensStmt, consumeDropTokens, arg.Tokens, arg.UserID)
	var i User
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Quote,
		&i.Date,
		&i.Favorite,
		&i.Tokens,
	)
	return i, err
}

const createUser = `-- name: createUser :exec
INSERT INTO users (user_id)
VALUES ($1)
`

func (q *Queries) createUser(ctx context.Context, userID uint64) error {
	_, err := q.exec(ctx, q.createUserStmt, createUser, userID)
	return err
}

const deleteChar = `-- name: deleteChar :one
DELETE FROM characters
WHERE user_id = $1
    AND id = $2
RETURNING user_id, id, image, name, date, type
`

type deleteCharParams struct {
	UserID uint64 `json:"user_id"`
	ID     int64  `json:"id"`
}

func (q *Queries) deleteChar(ctx context.Context, arg deleteCharParams) (Character, error) {
	row := q.queryRow(ctx, q.deleteCharStmt, deleteChar, arg.UserID, arg.ID)
	var i Character
	err := row.Scan(
		&i.UserID,
		&i.ID,
		&i.Image,
		&i.Name,
		&i.Date,
		&i.Type,
	)
	return i, err
}

const getChar = `-- name: getChar :one
SELECT user_id, id, image, name, date, type
FROM characters
WHERE id = $1
    AND characters.user_id = $2
`

type getCharParams struct {
	ID     int64  `json:"id"`
	UserID uint64 `json:"user_id"`
}

func (q *Queries) getChar(ctx context.Context, arg getCharParams) (Character, error) {
	row := q.queryRow(ctx, q.getCharStmt, getChar, arg.ID, arg.UserID)
	var i Character
	err := row.Scan(
		&i.UserID,
		&i.ID,
		&i.Image,
		&i.Name,
		&i.Date,
		&i.Type,
	)
	return i, err
}

const getChars = `-- name: getChars :many
SELECT user_id, id, image, name, date, type
FROM characters
WHERE characters.user_id = $1
ORDER BY characters.date DESC
`

func (q *Queries) getChars(ctx context.Context, userID uint64) ([]Character, error) {
	rows, err := q.query(ctx, q.getCharsStmt, getChars, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Character
	for rows.Next() {
		var i Character
		if err := rows.Scan(
			&i.UserID,
			&i.ID,
			&i.Image,
			&i.Name,
			&i.Date,
			&i.Type,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCharsID = `-- name: getCharsID :many
SELECT id
FROM characters
WHERE user_id = $1
`

func (q *Queries) getCharsID(ctx context.Context, userID uint64) ([]int64, error) {
	rows, err := q.query(ctx, q.getCharsIDStmt, getCharsID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int64
	for rows.Next() {
		var id int64
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCharsWhoseIDStartWith = `-- name: getCharsWhoseIDStartWith :many
SELECT user_id, id, image, name, date, type
FROM characters
WHERE characters.user_id = $1
    AND characters.id::varchar LIKE $2::string
ORDER BY characters.date DESC
LIMIT $4 OFFSET $3
`

type getCharsWhoseIDStartWithParams struct {
	UserID  uint64 `json:"user_id"`
	LikeStr string `json:"like_str"`
	Off     int32  `json:"off"`
	Lim     int32  `json:"lim"`
}

func (q *Queries) getCharsWhoseIDStartWith(ctx context.Context, arg getCharsWhoseIDStartWithParams) ([]Character, error) {
	rows, err := q.query(ctx, q.getCharsWhoseIDStartWithStmt, getCharsWhoseIDStartWith,
		arg.UserID,
		arg.LikeStr,
		arg.Off,
		arg.Lim,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Character
	for rows.Next() {
		var i Character
		if err := rows.Scan(
			&i.UserID,
			&i.ID,
			&i.Image,
			&i.Name,
			&i.Date,
			&i.Type,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProfile = `-- name: getProfile :one
SELECT characters.image as favorite_image,
    characters.name as favorite_name,
    characters.id as favorite_id,
    users.date as user_date,
    users.quote as user_quote,
    users.user_id as user_id,
    users.tokens as user_tokens,
    (
        SELECT count(id)
        FROM characters
        WHERE characters.user_id = $1
    ) as count
FROM users
    LEFT JOIN characters ON characters.id = users.favorite
WHERE users.user_id = $1
`

type getProfileRow struct {
	FavoriteImage sql.NullString `json:"favorite_image"`
	FavoriteName  sql.NullString `json:"favorite_name"`
	FavoriteID    sql.NullInt64  `json:"favorite_id"`
	UserDate      time.Time      `json:"user_date"`
	UserQuote     string         `json:"user_quote"`
	UserID        uint64         `json:"user_id"`
	UserTokens    int32          `json:"user_tokens"`
	Count         int64          `json:"count"`
}

func (q *Queries) getProfile(ctx context.Context, userID uint64) (getProfileRow, error) {
	row := q.queryRow(ctx, q.getProfileStmt, getProfile, userID)
	var i getProfileRow
	err := row.Scan(
		&i.FavoriteImage,
		&i.FavoriteName,
		&i.FavoriteID,
		&i.UserDate,
		&i.UserQuote,
		&i.UserID,
		&i.UserTokens,
		&i.Count,
	)
	return i, err
}

const getUser = `-- name: getUser :one
SELECT id, user_id, quote, date, favorite, tokens
FROM users
WHERE user_id = $1
`

func (q *Queries) getUser(ctx context.Context, userID uint64) (User, error) {
	row := q.queryRow(ctx, q.getUserStmt, getUser, userID)
	var i User
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Quote,
		&i.Date,
		&i.Favorite,
		&i.Tokens,
	)
	return i, err
}

const giveChar = `-- name: giveChar :one
UPDATE characters
SET "type" = 'TRADE',
    "user_id" = $1
WHERE characters.id = $2
    AND characters.user_id = $3
RETURNING user_id, id, image, name, date, type
`

type giveCharParams struct {
	Given int64 `json:"given"`
	ID    int64 `json:"id"`
	Giver int64 `json:"giver"`
}

func (q *Queries) giveChar(ctx context.Context, arg giveCharParams) (Character, error) {
	row := q.queryRow(ctx, q.giveCharStmt, giveChar, arg.Given, arg.ID, arg.Giver)
	var i Character
	err := row.Scan(
		&i.UserID,
		&i.ID,
		&i.Image,
		&i.Name,
		&i.Date,
		&i.Type,
	)
	return i, err
}

const insertChar = `-- name: insertChar :exec
INSERT INTO characters ("id", "user_id", "image", "name", "type")
VALUES ($1, $2, $3, $4, $5)
`

type insertCharParams struct {
	ID     int64  `json:"id"`
	UserID uint64 `json:"user_id"`
	Image  string `json:"image"`
	Name   string `json:"name"`
	Type   string `json:"type"`
}

func (q *Queries) insertChar(ctx context.Context, arg insertCharParams) error {
	_, err := q.exec(ctx, q.insertCharStmt, insertChar,
		arg.ID,
		arg.UserID,
		arg.Image,
		arg.Name,
		arg.Type,
	)
	return err
}
